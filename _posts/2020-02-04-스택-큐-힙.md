---
title:  "스택, 큐, 힙, 트리 등등"
excerpt: "자료구조 - 스택, 큐, 힙, 트리 등등"

header:
  overlay_image: https://images.unsplash.com/photo-1483266146383-f20258a83a77?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80

categories:
  - dev
  - 자료구조
---

#### 스택(stack)  
제한적으로 접근할 수 있는 나열 구조이다. 그 접근 방법은 언제나 목록의 끝에서만 일어난다. 끝먼저내기 목록(Pushdown list)이라고도 한다.  
원소들의 삽입과 삭제가 리스트의 한쪽 끝에서만 수행  
**Last In First Out(LIFO)** 포인터의 값을 1씩 증가 또는 감소시킴으로써 수행된다.

#### 큐(Queue)
한쪽끝에서는 삽입만 가능 다른한쪽끝에서는 삭제만 가능 하게 만든 리스트
**First In First Out(FIFO)**
rear가 배열의 끝에 도달했을 경우 메모리가 꽉 차있는것으로 판단할 수 있다.
Java에서 제공하고 있는 Queue는 인터페이스 형태로 LinkedList를 통해서 생성한다.  
그렇기 때문에 사이즈가 가변적이고, 쉽게 늘어난다.

#### 원형큐(Circular Queue)
선형 큐는 주기적으로 enqueue 되고 dequeue되면 인덱스를 조정하면서 front가 점차 뒤로 가게되면서 앞쪽 메모리 공간을 효율적으로 사용 할 수 없게 된다.  
원형 큐는 선형 큐의 문제점을 보완하기 위한 자료구조로 메모리의 재사용이 가능하다.  
단점은 배열로 구현되어 있기 때문에 큐의 크기가 제한되는 단점이 존재

#### 링버퍼(RingBuffer)
작년 가을에 예전 회사에서 거래소를 C로 만드냐 Java로 만들어야 하냐 질문받은 적이있어서
 Distruptor(https://github.com/LMAX-Exchange/disruptor)에 대해서 공부한적이 있었는데 오늘 관련질문을 받았는대 대답을 1도 못했다.  
머리가 굳었나보다. ㅠㅠ

https://www.slideshare.net/trishagee/a-users-guide-to-the-disruptor?ref=http://smallake.kr/?p=2254



#### ArrayList
장점 : 데이터는 인덱스를 가지고 있기 때문에 데이터 검색에 유리하다.  
단점 : 데이터를 추가 / 삭제 하는경우 성능저하  
ArrayList 클래스는 크기가 고정되어 있는 배열(Array)을 개선  
내부적으로 **배열**을 이용하여 요소를 저장한다.


#### LinkedList
장점 : 데이터의 추가 / 삭제 유리
단점 : 데이터 검색에 불리
블록체인에 블록이 다음 블록 값을 참조하는걸 생각하면 편할듯하다.


#### 이진트리(binary tree)
각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조

#### DFS와 BFS
**깊이 우선 탐색(Depth First Search)**  
탐색트리의 최근에 첨가된 노드를 선택하고, 이 노드에 적용 가능한 동작자 중 하나를 적용하여 트리에 다음 수준(level)의 한 개의 자식노드를 첨가하며, 첨가된 자식 노드가 목표노드일 때까지 앞의 자식 노드의 첨가 과정을 반복해 가는 방식이다.  
장점
- 단지 현 경로상의 노드들만을 기억하면 되므로 저장공간의 수요가 비교적 적다.  
- 목표노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있다.
단점
- 해가 없는 경로에 깊이 빠질 가능성이 있다. 따라서 실제의 경우 미리 지정한 임의의 깊이까지만 탐색하고 목표노드를 발견하지 못하면 다음의 경로를 따라 탐색하는 방법이 유용할 수 있다.
- 얻어진 해가 최단 경로가 된다는 보장이 없다. 이는 목표에 이르는 경로가 다수인 문제에 대해 깊이우선 탐색은 해에 다다르면 탐색을 끝내버리므로, 이때 얻어진 해는 최적이 아닐 수 있다는 의미이다.  
 **너비 우선 탐색(Breadth First Search)**  
 하나로 시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다. 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서도 너비 우선 검색을 적용한다. OPEN List 는 큐를 사용해야만 레벨 순서대로 접근이 가능하다.
장점
- 출발노드에서 목표노드까지의 최단 길이 경로를 보장한다.
단점
- 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 하게 된다.
- 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝난다.
- 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못한다.